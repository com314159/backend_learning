分布式锁是分布式系统中协调多节点对共享资源进行**互斥访问**的关键机制。下面我将从核心概念、常见实现、应用场景及选型建议为你梳理。

### 📊 分布式锁核心特性与实现对比

一个可靠的分布式锁应具备以下核心特性：

| **特性** | **描述** |
| :--- | :--- |
| **互斥性** | 在任意时刻，只有一个客户端能持有锁。 |
| **避免死锁** | 锁最终总能被释放，即使持有者崩溃（通常通过**超时机制**实现）。 |
| **可重入性** | 同一个客户端可以多次获取同一把锁。 |
| **高可用** | 锁服务本身需要高可用，不能成为单点故障。 |

分布式锁有多种实现方式，下表对比了主流的几种方案：

| **实现方式** | **核心原理** | **优点** | **缺点** | **适用场景** |
| :--- | :--- | :--- | :--- | :--- |
| **基于数据库** | 利用唯一约束或乐观锁版本号。 | 实现简单，无需引入新组件。 | 性能较差，易成瓶颈；需处理死锁和超时。 | 并发量低，且已依赖数据库的场景。 |
| **基于 Redis** | 使用 `SET key value NX EX seconds` 等原子指令。 | **性能极高**（内存操作），实现相对简单。 | 需注意锁误删、续期、集群故障时的可靠性。 | **高并发**场景，对一致性要求非最极端（如秒杀）。 |
| **基于 ZooKeeper** | 利用**临时顺序节点**和Watch机制。 | 可靠性高，自动释放（临时节点），天然公平。 | 性能稍逊于Redis，需维护ZK集群。 | 对**一致性要求极高**的场景（如金融核心交易）。 |
| **基于 etcd** | 基于Raft协议，提供强一致性。 | 高可用，强一致，提供租约（Lease）机制。 | 需额外维护etcd集群。 | 类似ZK，在云原生环境中更常见。 |

### ⚙️ 实现简介与最佳实践

1.  **基于Redis的实现（常用）**
    *   **加锁**：使用 `SET lock_name unique_value NX EX timeout` 原子命令。`unique_value`（如UUID）用于标识客户端，防止误删。
    *   **释放锁**：使用Lua脚本检查`unique_value`匹配后再删除，确保原子性。
    *   **锁续期**：若任务执行时间长，需额外机制（如Redisson的WatchDog）在锁过期前自动续期。
    *   **集群模式**：为应对Redis节点故障，可采用RedLock算法（争议较大），或使用官方高可用方案。

2.  **基于ZooKeeper的实现（高可靠）**
    *   所有客户端在锁目录下创建**临时顺序节点**。
    *   客户端检查自己是否为序号最小的节点。如果是，获得锁。
    *   如果不是，则监听它前一个节点的删除事件，进入等待。
    *   获得锁的客户端宕机时，其临时节点自动删除，从而自动释放锁。

3.  **最佳实践与常见问题**
    *   **设置超时时间**：所有实现都应设置锁超时，避免死锁。
    *   **检查锁标识**：释放锁时需验证持有者，防止误释。
    *   **避免主从切换问题**：在Redis异步复制下，主节点宕机可能导致锁信息丢失，RedLock或ZK能更好应对此场景。
    *   **使用成熟框架**：如 **Redisson**（Redis）或 **Curator**（ZooKeeper），它们封装了复杂性，提供了可重入锁、读写锁、联锁等高级特性。

### 🎯 典型应用场景

分布式锁广泛应用于需要**跨进程、跨机器互斥**的场景：

*   **防止超卖**：秒杀活动中扣减商品库存。
*   **重复幂等**：防止分布式任务调度器重复执行同一任务。
*   **全局状态同步**：确保同一时间只有一个节点能执行某个关键操作（如全局配置更新、唯一序列号生成）。
*   **避免重复工作**：如多个节点同时尝试刷新同一个分布式缓存。

### 💡 选型建议

*   **追求极致性能，允许极小概率的锁失效**：选择 **Redis**（配合Redisson）。
*   **追求绝对可靠，业务场景关键**：选择 **ZooKeeper** 或 **etcd**。
*   **系统简单，并发量很低**：可考虑**数据库**实现，避免引入新组件。

希望以上信息能帮助你更好地理解分布式锁。如果你对特定场景或更深入的技术细节有更多疑问，我很乐意继续探讨。
